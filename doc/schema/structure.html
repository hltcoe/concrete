<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="concrete-eapi.css"/>
  <script type="text/javascript" src="concrete_info.js"></script>
  <script type="text/javascript" src="concrete-eapi.js"></script>
  <script type="text/javascript" src="tablesorter/jquery-latest.js"></script>
  <script type="text/javascript" src="tablesorter/jquery.tablesorter.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      addConcreteNavigation();
    });
  </script>
<html>
 <head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <title>
   Thrift module: structure
  </title>
 </head>
 <body>
  <div class="container-fluid">
   <h1>
    Thrift module: structure
   </h1>
   <table class="table-bordered table-striped table-condensed">
    <thead>
     <th>
      Module
     </th>
     <th>
      Services
     </th>
     <th>
      Data types
     </th>
     <th>
      Constants
     </th>
    </thead>
    <tr>
     <td>
      structure
     </td>
     <td>
     </td>
     <td>
      <a href="#Struct_Arc">
       Arc
      </a>
      <br/>
      <a href="#Struct_Constituent">
       Constituent
      </a>
      <br/>
      <a href="#Struct_Dependency">
       Dependency
      </a>
      <br/>
      <a href="#Struct_DependencyParse">
       DependencyParse
      </a>
      <br/>
      <a href="#Struct_DependencyParseStructure">
       DependencyParseStructure
      </a>
      <br/>
      <a href="#Struct_LatticePath">
       LatticePath
      </a>
      <br/>
      <a href="#Struct_Parse">
       Parse
      </a>
      <br/>
      <a href="#Struct_Section">
       Section
      </a>
      <br/>
      <a href="#Struct_Sentence">
       Sentence
      </a>
      <br/>
      <a href="#Struct_TaggedToken">
       TaggedToken
      </a>
      <br/>
      <a href="#Struct_Token">
       Token
      </a>
      <br/>
      <a href="#Struct_TokenLattice">
       TokenLattice
      </a>
      <br/>
      <a href="#Struct_TokenList">
       TokenList
      </a>
      <br/>
      <a href="#Struct_TokenRefSequence">
       TokenRefSequence
      </a>
      <br/>
      <a href="#Struct_TokenTagging">
       TokenTagging
      </a>
      <br/>
      <a href="#Struct_Tokenization">
       Tokenization
      </a>
      <br/>
      <a href="#Enum_TokenizationKind">
       TokenizationKind
      </a>
      <br/>
     </td>
     <td>
     </td>
    </tr>
   </table>
   <hr/>
   <div id="Enumerations_div">
    <h2 id="Enumerations">
     Enumerations
    </h2>
    <div class="definition">
     <h3 id="Enum_TokenizationKind">
      Enumeration: TokenizationKind
     </h3>
     Enumerated types of Tokenizations
     <br/>
     <br/>
     <table class="table-bordered table-striped table-condensed">
      <tr>
       <td>
        <code>
         TOKEN_LIST
        </code>
       </td>
       <td>
        <code>
         1
        </code>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         TOKEN_LATTICE
        </code>
       </td>
       <td>
        <code>
         2
        </code>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
   </div>
   <hr/>
   <div id="Structs_div">
    <h2 id="Structs">
     Data structures
    </h2>
    <div class="definition">
     <h3 id="Struct_Arc">
      Struct: Arc
     </h3>
     <table class="table-bordered table-striped table-condensed">
      <thead>
       <th>
        Key
       </th>
       <th>
        Field
       </th>
       <th>
        Type
       </th>
       <th>
        Description
       </th>
       <th>
        Requiredness
       </th>
       <th>
        Default value
       </th>
      </thead>
      <tr>
       <td>
        1
       </td>
       <td>
        src
       </td>
       <td>
        <code>
         i32
        </code>
       </td>
       <td>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        dst
       </td>
       <td>
        <code>
         i32
        </code>
       </td>
       <td>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        token
       </td>
       <td>
        <code>
         <a href="structure.html#Struct_Token">
          Token
         </a>
        </code>
       </td>
       <td>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        weight
       </td>
       <td>
        <code>
         double
        </code>
       </td>
       <td>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
     </table>
     <br/>
     Type for arcs. For epsilon edges, leave 'token' blank.
     <br/>
    </div>
    <div class="definition">
     <h3 id="Struct_Constituent">
      Struct: Constituent
     </h3>
     <table class="table-bordered table-striped table-condensed">
      <thead>
       <th>
        Key
       </th>
       <th>
        Field
       </th>
       <th>
        Type
       </th>
       <th>
        Description
       </th>
       <th>
        Requiredness
       </th>
       <th>
        Default value
       </th>
      </thead>
      <tr>
       <td>
        1
       </td>
       <td>
        id
       </td>
       <td>
        <code>
         i32
        </code>
       </td>
       <td>
        A parse-relative identifier for this consistuent. Together
        <br/>
        with the UUID for a Parse, this can be used to define
        <br/>
        pointers to specific constituents.
        <br/>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        tag
       </td>
       <td>
        <code>
         string
        </code>
       </td>
       <td>
        A description of this constituency node, e.g. the category "NP".
        <br/>
        For leaf nodes, this should be a word and for pre-terminal nodes
        <br/>
        this should be a POS tag.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        childList
       </td>
       <td>
        <code>
         list&lt;
         <code>
          i32
         </code>
         &gt;
        </code>
       </td>
       <td>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        headChildIndex
       </td>
       <td>
        <code>
         i32
        </code>
       </td>
       <td>
        The index of the head child of this constituent. I.e., the
        <br/>
        head child of constituent
        <tt>
         c
        </tt>
        is
        <br/>
        <tt>
         c.children[c.head_child_index]
        </tt>
        . A value of -1
        <br/>
        indicates that no child head was identified.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
        -1
       </td>
      </tr>
      <tr>
       <td>
        5
       </td>
       <td>
        start
       </td>
       <td>
        <code>
         i32
        </code>
       </td>
       <td>
        The first token (inclusive) of this constituent in the
        <br/>
        parent Tokenization. Almost certainly should be populated.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        6
       </td>
       <td>
        ending
       </td>
       <td>
        <code>
         i32
        </code>
       </td>
       <td>
        The last token (exclusive) of this constituent in the
        <br/>
        parent Tokenization. Almost certainly should be populated.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
     </table>
     <br/>
     A single parse constituent (or "phrase").
     <br/>
    </div>
    <div class="definition">
     <h3 id="Struct_Dependency">
      Struct: Dependency
     </h3>
     <table class="table-bordered table-striped table-condensed">
      <thead>
       <th>
        Key
       </th>
       <th>
        Field
       </th>
       <th>
        Type
       </th>
       <th>
        Description
       </th>
       <th>
        Requiredness
       </th>
       <th>
        Default value
       </th>
      </thead>
      <tr>
       <td>
        1
       </td>
       <td>
        gov
       </td>
       <td>
        <code>
         i32
        </code>
       </td>
       <td>
        The governor or the head token. 0 indexed.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
        -1
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        dep
       </td>
       <td>
        <code>
         i32
        </code>
       </td>
       <td>
        The dependent token. 0 indexed.
        <br/>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        edgeType
       </td>
       <td>
        <code>
         string
        </code>
       </td>
       <td>
        The relation that holds between gov and dep.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
     </table>
     <br/>
     A syntactic edge between two tokens in a tokenized sentence.
     <br/>
    </div>
    <div class="definition">
     <h3 id="Struct_DependencyParse">
      Struct: DependencyParse
     </h3>
     <table class="table-bordered table-striped table-condensed">
      <thead>
       <th>
        Key
       </th>
       <th>
        Field
       </th>
       <th>
        Type
       </th>
       <th>
        Description
       </th>
       <th>
        Requiredness
       </th>
       <th>
        Default value
       </th>
      </thead>
      <tr>
       <td>
        1
       </td>
       <td>
        uuid
       </td>
       <td>
        <code>
         <a href="uuid.html#Struct_UUID">
          uuid.UUID
         </a>
        </code>
       </td>
       <td>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        metadata
       </td>
       <td>
        <code>
         <a href="metadata.html#Struct_AnnotationMetadata">
          metadata.AnnotationMetadata
         </a>
        </code>
       </td>
       <td>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        dependencyList
       </td>
       <td>
        <code>
         list&lt;
         <code>
          <a href="structure.html#Struct_Dependency">
           Dependency
          </a>
         </code>
         &gt;
        </code>
       </td>
       <td>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        structureInformation
       </td>
       <td>
        <code>
         <a href="structure.html#Struct_DependencyParseStructure">
          DependencyParseStructure
         </a>
        </code>
       </td>
       <td>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
     </table>
     <br/>
     Represents a dependency parse with typed edges.
     <br/>
    </div>
    <div class="definition">
     <h3 id="Struct_DependencyParseStructure">
      Struct: DependencyParseStructure
     </h3>
     <table class="table-bordered table-striped table-condensed">
      <thead>
       <th>
        Key
       </th>
       <th>
        Field
       </th>
       <th>
        Type
       </th>
       <th>
        Description
       </th>
       <th>
        Requiredness
       </th>
       <th>
        Default value
       </th>
      </thead>
      <tr>
       <td>
        1
       </td>
       <td>
        isAcyclic
       </td>
       <td>
        <code>
         bool
        </code>
       </td>
       <td>
        True iff there are no cycles in the dependency graph.
        <br/>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        isConnected
       </td>
       <td>
        <code>
         bool
        </code>
       </td>
       <td>
        True iff the dependency graph forms a single connected component.
        <br/>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        isSingleHeaded
       </td>
       <td>
        <code>
         bool
        </code>
       </td>
       <td>
        True iff every node in the dependency parse has at most
        <br/>
        one head/parent/governor.
        <br/>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        isProjective
       </td>
       <td>
        <code>
         bool
        </code>
       </td>
       <td>
        True iff there are no crossing edges in the dependency parse.
        <br/>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
     </table>
     <br/>
     Information about the structure of a dependency parse.
This information is computable from the list of dependencies,
but this allows the consumer to make (verified) assumptions
about the dependencies being processed.
     <br/>
    </div>
    <div class="definition">
     <h3 id="Struct_LatticePath">
      Struct: LatticePath
     </h3>
     <table class="table-bordered table-striped table-condensed">
      <thead>
       <th>
        Key
       </th>
       <th>
        Field
       </th>
       <th>
        Type
       </th>
       <th>
        Description
       </th>
       <th>
        Requiredness
       </th>
       <th>
        Default value
       </th>
      </thead>
      <tr>
       <td>
        1
       </td>
       <td>
        weight
       </td>
       <td>
        <code>
         double
        </code>
       </td>
       <td>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        tokenList
       </td>
       <td>
        <code>
         list&lt;
         <code>
          <a href="structure.html#Struct_Token">
           Token
          </a>
         </code>
         &gt;
        </code>
       </td>
       <td>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
     </table>
     <br/>
    </div>
    <div class="definition">
     <h3 id="Struct_Parse">
      Struct: Parse
     </h3>
     <table class="table-bordered table-striped table-condensed">
      <thead>
       <th>
        Key
       </th>
       <th>
        Field
       </th>
       <th>
        Type
       </th>
       <th>
        Description
       </th>
       <th>
        Requiredness
       </th>
       <th>
        Default value
       </th>
      </thead>
      <tr>
       <td>
        1
       </td>
       <td>
        uuid
       </td>
       <td>
        <code>
         <a href="uuid.html#Struct_UUID">
          uuid.UUID
         </a>
        </code>
       </td>
       <td>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        metadata
       </td>
       <td>
        <code>
         <a href="metadata.html#Struct_AnnotationMetadata">
          metadata.AnnotationMetadata
         </a>
        </code>
       </td>
       <td>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        constituentList
       </td>
       <td>
        <code>
         list&lt;
         <code>
          <a href="structure.html#Struct_Constituent">
           Constituent
          </a>
         </code>
         &gt;
        </code>
       </td>
       <td>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
     </table>
     <br/>
     A theory about the syntactic parse of a sentence.
     <p>
     </p>
     \note If we add support for parse forests in the future, then it
will most likely be done by adding a new field (e.g.
"
     <tt>
      forest_root
     </tt>
     ") that uses a new struct type to encode the
forest. A "
     <tt>
      kind
     </tt>
     " field might also be added (analogous to
     <tt>
      Tokenization.kind
     </tt>
     ) to indicate whether a parse is encoded
using a simple tree or a parse forest.
     <br/>
    </div>
    <div class="definition">
     <h3 id="Struct_Section">
      Struct: Section
     </h3>
     <table class="table-bordered table-striped table-condensed">
      <thead>
       <th>
        Key
       </th>
       <th>
        Field
       </th>
       <th>
        Type
       </th>
       <th>
        Description
       </th>
       <th>
        Requiredness
       </th>
       <th>
        Default value
       </th>
      </thead>
      <tr>
       <td>
        1
       </td>
       <td>
        uuid
       </td>
       <td>
        <code>
         <a href="uuid.html#Struct_UUID">
          uuid.UUID
         </a>
        </code>
       </td>
       <td>
        The unique identifier for this section.
        <br/>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        sentenceList
       </td>
       <td>
        <code>
         list&lt;
         <code>
          <a href="structure.html#Struct_Sentence">
           Sentence
          </a>
         </code>
         &gt;
        </code>
       </td>
       <td>
        Theories about how this section is divided into sentences.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        textSpan
       </td>
       <td>
        <code>
         <a href="spans.html#Struct_TextSpan">
          spans.TextSpan
         </a>
        </code>
       </td>
       <td>
        Location of this section in the communication text.
        <br/>
        <br/>
        NOTE: This text span represents a best guess, or 'provenance':
        <br/>
        it cannot be guaranteed that this text span matches the _exact_
        <br/>
        text of the original document, but is the annotation's best
        <br/>
        effort at such a representation.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        rawTextSpan
       </td>
       <td>
        <code>
         <a href="spans.html#Struct_TextSpan">
          spans.TextSpan
         </a>
        </code>
       </td>
       <td>
        Location of this section in the raw text.
        <br/>
        <br/>
        NOTE: This text span represents a best guess, or 'provenance':
        <br/>
        it cannot be guaranteed that this text span matches the _exact_
        <br/>
        text of the original document, but is the annotation's best
        <br/>
        effort at such a representation.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        9
       </td>
       <td>
        audioSpan
       </td>
       <td>
        <code>
         <a href="spans.html#Struct_AudioSpan">
          spans.AudioSpan
         </a>
        </code>
       </td>
       <td>
        Location of this section in the original audio.
        <br/>
        <br/>
        NOTE: This span represents a best guess, or 'provenance':
        <br/>
        it cannot be guaranteed that this text span matches the _exact_
        <br/>
        text of the original document, but is the annotation's best
        <br/>
        effort at such a representation.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        5
       </td>
       <td>
        kind
       </td>
       <td>
        <code>
         string
        </code>
       </td>
       <td>
        The type of this section.
        <br/>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        6
       </td>
       <td>
        label
       </td>
       <td>
        <code>
         string
        </code>
       </td>
       <td>
        The name of the section. For example, a title of a section on
        <br/>
        Wikipedia.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        7
       </td>
       <td>
        numberList
       </td>
       <td>
        <code>
         list&lt;
         <code>
          i32
         </code>
         &gt;
        </code>
       </td>
       <td>
        Position within the communication with respect to other Sections:
        <br/>
        The section number, E.g., 3, or 3.1, or 3.1.2, etc. Aimed at
        <br/>
        Communications with content organized in a hierarchy, such as a Book
        <br/>
        with multiple chapters, then sections, then paragraphs. Or even a
        <br/>
        dense Wikipedia page with subsections. Sections should still be
        <br/>
        arranged linearly, where reading these numbers should not be required
        <br/>
        to get a start-to-finish enumeration of the Communication's content.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
     </table>
     <br/>
     A single "section" of a communication, such as a paragraph. Each
section is defined using a text or audio span, and can optionally
contain a list of sentences.
     <br/>
    </div>    <div class="definition">
     <h3 id="Struct_Sentence">
      Struct: Sentence
     </h3>
     <table class="table-bordered table-striped table-condensed">
      <thead>
       <th>
        Key
       </th>
       <th>
        Field
       </th>
       <th>
        Type
       </th>
       <th>
        Description
       </th>
       <th>
        Requiredness
       </th>
       <th>
        Default value
       </th>
      </thead>
      <tr>
       <td>
        1
       </td>
       <td>
        uuid
       </td>
       <td>
        <code>
         <a href="uuid.html#Struct_UUID">
          uuid.UUID
         </a>
        </code>
       </td>
       <td>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        tokenization
       </td>
       <td>
        <code>
         <a href="structure.html#Struct_Tokenization">
          Tokenization
         </a>
        </code>
       </td>
       <td>
        Theories about the tokens that make up this sentence.  For text
        <br/>
        communications, these tokenizations will typically be generated
        <br/>
        by a tokenizer.  For audio communications, these tokenizations
        <br/>
        will typically be generated by an automatic speech recognizer.
        <br/>
        <br/>
        The "Tokenization" message type is also used to store the output
        <br/>
        of machine translation systems and text normalization
        <br/>
        systems.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        textSpan
       </td>
       <td>
        <code>
         <a href="spans.html#Struct_TextSpan">
          spans.TextSpan
         </a>
        </code>
       </td>
       <td>
        Location of this sentence in the communication text.
        <br/>
        <br/>
        NOTE: This span represents a best guess, or 'provenance':
        <br/>
        it cannot be guaranteed that this text span matches the _exact_
        <br/>
        text of the original document, but is the annotation's best
        <br/>
        effort at such a representation.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        rawTextSpan
       </td>
       <td>
        <code>
         <a href="spans.html#Struct_TextSpan">
          spans.TextSpan
         </a>
        </code>
       </td>
       <td>
        Location of this sentence in the raw text.
        <br/>
        <br/>
        NOTE: This span represents a best guess, or 'provenance':
        <br/>
        it cannot be guaranteed that this text span matches the _exact_
        <br/>
        text of the original document, but is the annotation's best
        <br/>
        effort at such a representation.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        5
       </td>
       <td>
        audioSpan
       </td>
       <td>
        <code>
         <a href="spans.html#Struct_AudioSpan">
          spans.AudioSpan
         </a>
        </code>
       </td>
       <td>
        Location of this sentence in the original audio.
        <br/>
        <br/>
        NOTE: This span represents a best guess, or 'provenance':
        <br/>
        it cannot be guaranteed that this text span matches the _exact_
        <br/>
        text of the original document, but is the annotation's best
        <br/>
        effort at such a representation.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
     </table>
     <br/>
     A single sentence or utterance in a communication.
     <br/>
    </div>
    <div class="definition">
     <h3 id="Struct_TaggedToken">
      Struct: TaggedToken
     </h3>
     <table class="table-bordered table-striped table-condensed">
      <thead>
       <th>
        Key
       </th>
       <th>
        Field
       </th>
       <th>
        Type
       </th>
       <th>
        Description
       </th>
       <th>
        Requiredness
       </th>
       <th>
        Default value
       </th>
      </thead>
      <tr>
       <td>
        1
       </td>
       <td>
        tokenIndex
       </td>
       <td>
        <code>
         i32
        </code>
       </td>
       <td>
        A pointer to the token being tagged.
        <br/>
        <br/>
        Token indices are 0-based. These indices are also 0-based.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        tag
       </td>
       <td>
        <code>
         string
        </code>
       </td>
       <td>
        A string containing the annotation.
        <br/>
        If the tag set you are using is not case sensitive,
        <br/>
        then all part of speech tags should be normalized to upper case.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        confidence
       </td>
       <td>
        <code>
         double
        </code>
       </td>
       <td>
        Confidence of the annotation.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        tagList
       </td>
       <td>
        <code>
         list&lt;
         <code>
          string
         </code>
         &gt;
        </code>
       </td>
       <td>
        A list of strings that represent a distribution of possible
        <br/>
        tags for this token.
        <br/>
        <br/>
        If populated, the 'tag' field should also be populated
        <br/>
        with the "best" value from this list.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        5
       </td>
       <td>
        confidenceList
       </td>
       <td>
        <code>
         list&lt;
         <code>
          double
         </code>
         &gt;
        </code>
       </td>
       <td>
        A list of doubles that represent confidences associated with
        <br/>
        the tags in the 'tagList' field.
        <br/>
        <br/>
        If populated, the 'confidence' field should also be populated
        <br/>
        with the confidence associated with the "best" tag in 'tagList'.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
     </table>
     <br/>
    </div>
    <div class="definition">
     <h3 id="Struct_Token">
      Struct: Token
     </h3>
     <table class="table-bordered table-striped table-condensed">
      <thead>
       <th>
        Key
       </th>
       <th>
        Field
       </th>
       <th>
        Type
       </th>
       <th>
        Description
       </th>
       <th>
        Requiredness
       </th>
       <th>
        Default value
       </th>
      </thead>
      <tr>
       <td>
        1
       </td>
       <td>
        tokenIndex
       </td>
       <td>
        <code>
         i32
        </code>
       </td>
       <td>
        A 0-based tokenization-relative identifier for this token that
        <br/>
        represents the order that this token appears in the
        <br/>
        sentence. Together with the UUID for a Tokenization, this can be
        <br/>
        used to define pointers to specific tokens. If a Tokenization
        <br/>
        object contains multiple Token objects with the same id (e.g., in
        <br/>
        different n-best lists), then all of their other fields *must* be
        <br/>
        identical as well.
        <br/>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        text
       </td>
       <td>
        <code>
         string
        </code>
       </td>
       <td>
        The text associated with this token.
        <br/>
        Note - we may have a destructive tokenizer (e.g., Stanford rewriting)
        <br/>
        and as a result, we want to maintain this field.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        textSpan
       </td>
       <td>
        <code>
         <a href="spans.html#Struct_TextSpan">
          spans.TextSpan
         </a>
        </code>
       </td>
       <td>
        Location of this token in this perspective's text (.text field).
        <br/>
        In cases where this token does not correspond directly with any
        <br/>
        text span in the text (such as word insertion during MT),
        <br/>
        this field may be given a value indicating "approximately" where
        <br/>
        the token comes from. A span covering the entire sentence may be
        <br/>
        used if no more precise value seems appropriate.
        <br/>
        <br/>
        NOTE: This span represents a best guess, or 'provenance':
        <br/>
        it cannot be guaranteed that this text span matches the _exact_
        <br/>
        text of the document, but is the annotation's best
        <br/>
        effort at such a representation.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        rawTextSpan
       </td>
       <td>
        <code>
         <a href="spans.html#Struct_TextSpan">
          spans.TextSpan
         </a>
        </code>
       </td>
       <td>
        Location of this token in the original, raw text (.originalText
        <br/>
        field).  In cases where this token does not correspond directly
        <br/>
        with any text span in the original text (such as word insertion
        <br/>
        during MT), this field may be given a value indicating
        <br/>
        "approximately" where the token comes from. A span covering the
        <br/>
        entire sentence may be used if no more precise value seems
        <br/>
        appropriate.
        <br/>
        <br/>
        NOTE: This span represents a best guess, or 'provenance':
        <br/>
        it cannot be guaranteed that this text span matches the _exact_
        <br/>
        text of the original raw document, but is the annotation's best
        <br/>
        effort at such a representation.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        5
       </td>
       <td>
        audioSpan
       </td>
       <td>
        <code>
         <a href="spans.html#Struct_AudioSpan">
          spans.AudioSpan
         </a>
        </code>
       </td>
       <td>
        Location of this token in the original audio.
        <br/>
        <br/>
        NOTE: This span represents a best guess, or 'provenance':
        <br/>
        it cannot be guaranteed that this text span matches the _exact_
        <br/>
        text of the original document, but is the annotation's best
        <br/>
        effort at such a representation.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
     </table>
     <br/>
     A single token (typically a word) in a communication. The exact
definition of what counts as a token is left up to the tools that
generate token sequences.
     <p>
     </p>
     Usually, each token will include at least a text string.
     <br/>
    </div>
    <div class="definition">
     <h3 id="Struct_TokenLattice">
      Struct: TokenLattice
     </h3>
     <table class="table-bordered table-striped table-condensed">
      <thead>
       <th>
        Key
       </th>
       <th>
        Field
       </th>
       <th>
        Type
       </th>
       <th>
        Description
       </th>
       <th>
        Requiredness
       </th>
       <th>
        Default value
       </th>
      </thead>
      <tr>
       <td>
        1
       </td>
       <td>
        startState
       </td>
       <td>
        <code>
         i32
        </code>
       </td>
       <td>
       </td>
       <td>
        optional
       </td>
       <td>
        0
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        endState
       </td>
       <td>
        <code>
         i32
        </code>
       </td>
       <td>
       </td>
       <td>
        optional
       </td>
       <td>
        0
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        arcList
       </td>
       <td>
        <code>
         list&lt;
         <code>
          <a href="structure.html#Struct_Arc">
           Arc
          </a>
         </code>
         &gt;
        </code>
       </td>
       <td>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        cachedBestPath
       </td>
       <td>
        <code>
         <a href="structure.html#Struct_LatticePath">
          LatticePath
         </a>
        </code>
       </td>
       <td>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
     </table>
     <br/>
     A lattice structure that assigns scores to a set of token
sequences.  The lattice is encoded as an FSA, where states are
identified by integers, and each arc is annotated with an
optional tokens and a weight.  (Arcs with no tokens are
"epsilon" arcs.)  The lattice has a single start state and a
single end state.  (You can use epsilon edges to simulate
multiple start states or multiple end states, if desired.)
     <p>
     </p>
     The score of a path through the lattice is the sum of the weights
of the arcs that make up that path.  A path with a lower score
is considered "better" than a path with a higher score.
     <p>
     </p>
     If possible, path scores should be negative log likelihoods
(with base e -- e.g. if P=1, then weight=0; and if P=0.5, then
weight=0.693).  Furthermore, if possible, the path scores should
be globally normalized (i.e., they should encode probabilities).
This will allow for them to be combined with other information
in a reasonable way when determining confidences for system
outputs.
     <p>
     </p>
     TokenLattices should never contain any paths with cycles.  Every
arc in the lattice should be included in some path from the start
state to the end state.
     <br/>
    </div>
    <div class="definition">
     <h3 id="Struct_TokenList">
      Struct: TokenList
     </h3>
     <table class="table-bordered table-striped table-condensed">
      <thead>
       <th>
        Key
       </th>
       <th>
        Field
       </th>
       <th>
        Type
       </th>
       <th>
        Description
       </th>
       <th>
        Requiredness
       </th>
       <th>
        Default value
       </th>
      </thead>
      <tr>
       <td>
        1
       </td>
       <td>
        tokenList
       </td>
       <td>
        <code>
         list&lt;
         <code>
          <a href="structure.html#Struct_Token">
           Token
          </a>
         </code>
         &gt;
        </code>
       </td>
       <td>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
     </table>
     <br/>
     A wrapper around a list of tokens.
     <br/>
    </div>
    <div class="definition">
     <h3 id="Struct_TokenRefSequence">
      Struct: TokenRefSequence
     </h3>
     <table class="table-bordered table-striped table-condensed">
      <thead>
       <th>
        Key
       </th>
       <th>
        Field
       </th>
       <th>
        Type
       </th>
       <th>
        Description
       </th>
       <th>
        Requiredness
       </th>
       <th>
        Default value
       </th>
      </thead>
      <tr>
       <td>
        1
       </td>
       <td>
        tokenIndexList
       </td>
       <td>
        <code>
         list&lt;
         <code>
          i32
         </code>
         &gt;
        </code>
       </td>
       <td>
        The tokenization-relative identifiers for each token that is
        <br/>
        included in this sequence.
        <br/>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        anchorTokenIndex
       </td>
       <td>
        <code>
         i32
        </code>
       </td>
       <td>
        An optional field that can be used to describe
        <br/>
        the root of a sentence (if this sequence is a full sentence),
        <br/>
        the head of a constituent (if this sequence is a constituent),
        <br/>
        or some other form of "canonical" token in this sequence if,
        <br/>
        for instance, it is not easy to map this sequence to a another
        <br/>
        annotation that has a head.
        <br/>
        <br/>
        This field is defined with respect to the Tokenization given
        <br/>
        by tokenizationId, and not to this object's tokenIndexList.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
        -1
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        tokenizationId
       </td>
       <td>
        <code>
         <a href="uuid.html#Struct_UUID">
          uuid.UUID
         </a>
        </code>
       </td>
       <td>
        The UUID of the tokenization that contains the tokens.
        <br/>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        textSpan
       </td>
       <td>
        <code>
         <a href="spans.html#Struct_TextSpan">
          spans.TextSpan
         </a>
        </code>
       </td>
       <td>
        The text span in the main text (.text field) associated with this
        <br/>
        TokenRefSequence.
        <br/>
        <br/>
        NOTE: This span represents a best guess, or 'provenance': it
        <br/>
        cannot be guaranteed that this text span matches the _exact_ text
        <br/>
        of the original document, but is the annotation's best effort at
        <br/>
        such a representation.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        5
       </td>
       <td>
        rawTextSpan
       </td>
       <td>
        <code>
         <a href="spans.html#Struct_TextSpan">
          spans.TextSpan
         </a>
        </code>
       </td>
       <td>
        The text span in the original text (.originalText field)
        <br/>
        associated with this TokenRefSequence.
        <br/>
        <br/>
        NOTE: This span represents a best guess, or 'provenance': it
        <br/>
        cannot be guaranteed that this text span matches the _exact_ text
        <br/>
        of the original raw document, but is the annotation's best effort
        <br/>
        at such a representation.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        6
       </td>
       <td>
        audioSpan
       </td>
       <td>
        <code>
         <a href="spans.html#Struct_AudioSpan">
          spans.AudioSpan
         </a>
        </code>
       </td>
       <td>
        The audio span associated with this TokenRefSequence.
        <br/>
        <br/>
        NOTE: This span represents a best guess, or 'provenance':
        <br/>
        it cannot be guaranteed that this text span matches the _exact_
        <br/>
        text of the original document, but is the annotation's best
        <br/>
        effort at such a representation.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
     </table>
     <br/>
     A list of pointers to tokens that all belong to the same
tokenization.
     <br/>
    </div>
    <div class="definition">
     <h3 id="Struct_TokenTagging">
      Struct: TokenTagging
     </h3>
     <table class="table-bordered table-striped table-condensed">
      <thead>
       <th>
        Key
       </th>
       <th>
        Field
       </th>
       <th>
        Type
       </th>
       <th>
        Description
       </th>
       <th>
        Requiredness
       </th>
       <th>
        Default value
       </th>
      </thead>
      <tr>
       <td>
        1
       </td>
       <td>
        uuid
       </td>
       <td>
        <code>
         <a href="uuid.html#Struct_UUID">
          uuid.UUID
         </a>
        </code>
       </td>
       <td>
        The UUID of this TokenTagging object.
        <br/>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        metadata
       </td>
       <td>
        <code>
         <a href="metadata.html#Struct_AnnotationMetadata">
          metadata.AnnotationMetadata
         </a>
        </code>
       </td>
       <td>
        Information about where the annotation came from.
        <br/>
        This should be used to tell between gold-standard annotations
        <br/>
        and automatically-generated theories about the data
        <br/>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        taggedTokenList
       </td>
       <td>
        <code>
         list&lt;
         <code>
          <a href="structure.html#Struct_TaggedToken">
           TaggedToken
          </a>
         </code>
         &gt;
        </code>
       </td>
       <td>
        The mapping from tokens to annotations.
        <br/>
        This may be a partial mapping.
        <br/>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        taggingType
       </td>
       <td>
        <code>
         string
        </code>
       </td>
       <td>
        An ontology-backed string that represents the
        <br/>
        type of token taggings this TokenTagging object
        <br/>
        produces.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
     </table>
     <br/>
     A theory about some token-level annotation.
The TokenTagging consists of a mapping from tokens
(using token ids) to string tags (e.g. part-of-speech tags or lemmas).
     <p>
     </p>
     The mapping defined by a TokenTagging may be partial --
i.e., some tokens may not be assigned any part of speech tags.
     <p>
     </p>
     For lattice tokenizations, you may need to create multiple
part-of-speech taggings (for different paths through the lattice),
since the appropriate tag for a given token may depend on the path
taken. For example, you might define a separate
TokenTagging for each of the top K paths, which leaves all
tokens that are not part of the path unlabeled.
     <p>
     </p>
     Currently, we use strings to encode annotations. In
the future, we may add fields for encoding specific tag sets
(eg treebank tags), or for adding compound tags.
     <br/>
    </div>
    <div class="definition">
     <h3 id="Struct_Tokenization">
      Struct: Tokenization
     </h3>
     <table class="table-bordered table-striped table-condensed">
      <thead>
       <th>
        Key
       </th>
       <th>
        Field
       </th>
       <th>
        Type
       </th>
       <th>
        Description
       </th>
       <th>
        Requiredness
       </th>
       <th>
        Default value
       </th>
      </thead>
      <tr>
       <td>
        1
       </td>
       <td>
        uuid
       </td>
       <td>
        <code>
         <a href="uuid.html#Struct_UUID">
          uuid.UUID
         </a>
        </code>
       </td>
       <td>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        metadata
       </td>
       <td>
        <code>
         <a href="metadata.html#Struct_AnnotationMetadata">
          metadata.AnnotationMetadata
         </a>
        </code>
       </td>
       <td>
        Information about where this tokenization came from.
        <br/>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        tokenList
       </td>
       <td>
        <code>
         <a href="structure.html#Struct_TokenList">
          TokenList
         </a>
        </code>
       </td>
       <td>
        A wrapper around an ordered list of the tokens in this tokenization.
        <br/>
        This may also give easy access to the "reconstructed text" associated
        <br/>
        with this tokenization.
        <br/>
        This field should only have a value if kind==TOKEN_LIST.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        lattice
       </td>
       <td>
        <code>
         <a href="structure.html#Struct_TokenLattice">
          TokenLattice
         </a>
        </code>
       </td>
       <td>
        A lattice that compactly describes a set of token sequences that
        <br/>
        might make up this tokenization.  This field should only have a
        <br/>
        value if kind==LATTICE.
        <br/>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        5
       </td>
       <td>
        kind
       </td>
       <td>
        <code>
         <a href="structure.html#Enum_TokenizationKind">
          TokenizationKind
         </a>
        </code>
       </td>
       <td>
        Enumerated value indicating whether this tokenization is
        <br/>
        implemented using an n-best list or a lattice.
        <br/>
       </td>
       <td>
        required
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        6
       </td>
       <td>
        tokenTaggingList
       </td>
       <td>
        <code>
         list&lt;
         <code>
          <a href="structure.html#Struct_TokenTagging">
           TokenTagging
          </a>
         </code>
         &gt;
        </code>
       </td>
       <td>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        7
       </td>
       <td>
        parseList
       </td>
       <td>
        <code>
         list&lt;
         <code>
          <a href="structure.html#Struct_Parse">
           Parse
          </a>
         </code>
         &gt;
        </code>
       </td>
       <td>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        8
       </td>
       <td>
        dependencyParseList
       </td>
       <td>
        <code>
         list&lt;
         <code>
          <a href="structure.html#Struct_DependencyParse">
           DependencyParse
          </a>
         </code>
         &gt;
        </code>
       </td>
       <td>
       </td>
       <td>
        optional
       </td>
       <td>
       </td>
      </tr>
     </table>
     <br/>
     A theory (or set of alternative theories) about the sequence of
tokens that make up a sentence.
     <p>
     </p>
     This message type is used to record the output of not just for
tokenizers, but also for a wide variety of other tools, including
machine translation systems, text normalizers, part-of-speech
taggers, and stemmers.
     <p>
     </p>
     Each Tokenization is encoded using either a TokenList
or a TokenLattice. (If you want to encode an n-best list, then
you should store it as n separate Tokenization objects.) The
"kind" field is used to indicate whether this Tokenization contains
a list of tokens or a TokenLattice.
     <p>
     </p>
     The confidence value for each sequence is determined by combining
the confidence from the "metadata" field with confidence
information from individual token sequences as follows:
     <p>
     </p>
     <ul>
      <li>
       For n-best lists:
metadata.confidence
      </li>
      <li>
       For lattices:
metadata.confidence * exp(-sum(arc.weight))
      </li>
     </ul>
     <p>
     </p>
     Note: in some cases (such as the output of a machine translation
tool), the order of the tokens in a token sequence may not
correspond with the order of their original text span offsets.
     <br/>
    </div>
   </div>
  </div>
 </body>
</html>

