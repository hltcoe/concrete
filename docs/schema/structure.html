<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="concrete-eapi.css"/>
  <script type="text/javascript" src="concrete_info.js"></script>
  <script type="text/javascript" src="concrete-eapi.js"></script>
  <script type="text/javascript" src="tablesorter/jquery-latest.js"></script>
  <script type="text/javascript" src="tablesorter/jquery.tablesorter.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      addConcreteNavigation();
    });
  </script>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
<title>
 Thrift module: structure
</title>
<body>
 <div class="container-fluid">
  <h1>
   Thrift module: structure
  </h1>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Module
    </th>
    <th>
     Services
    </th>
    <th>
     Data types
    </th>
    <th>
     Constants
    </th>
   </thead>
   <tr>
    <td>
     structure
    </td>
    <td>
    </td>
    <td>
     <a href="#Struct_Arc">
      Arc
     </a>
     <br/>
     <a href="#Struct_Constituent">
      Constituent
     </a>
     <br/>
     <a href="#Struct_ConstituentRef">
      ConstituentRef
     </a>
     <br/>
     <a href="#Struct_Dependency">
      Dependency
     </a>
     <br/>
     <a href="#Struct_DependencyParse">
      DependencyParse
     </a>
     <br/>
     <a href="#Struct_DependencyParseStructure">
      DependencyParseStructure
     </a>
     <br/>
     <a href="#Struct_LatticePath">
      LatticePath
     </a>
     <br/>
     <a href="#Struct_Parse">
      Parse
     </a>
     <br/>
     <a href="#Struct_Section">
      Section
     </a>
     <br/>
     <a href="#Struct_Sentence">
      Sentence
     </a>
     <br/>
     <a href="#Struct_SpanLink">
      SpanLink
     </a>
     <br/>
     <a href="#Struct_TaggedToken">
      TaggedToken
     </a>
     <br/>
     <a href="#Struct_Token">
      Token
     </a>
     <br/>
     <a href="#Struct_TokenLattice">
      TokenLattice
     </a>
     <br/>
     <a href="#Struct_TokenList">
      TokenList
     </a>
     <br/>
     <a href="#Struct_TokenRefSequence">
      TokenRefSequence
     </a>
     <br/>
     <a href="#Struct_TokenTagging">
      TokenTagging
     </a>
     <br/>
     <a href="#Struct_Tokenization">
      Tokenization
     </a>
     <br/>
     <a href="#Enum_TokenizationKind">
      TokenizationKind
     </a>
     <br/>
    </td>
    <td>
    </td>
   </tr>
  </table>
 </div>
</body>
<hr/>
<div id="Enumerations_div">
 <h2 id="Enumerations">
  Enumerations
 </h2>
 <div class="definition">
  <h3 id="Enum_TokenizationKind">
   Enumeration: TokenizationKind
  </h3>
  Enumerated types of Tokenizations
  <br/>
  <br/>
  <table class="table-bordered table-striped table-condensed">
   <tr>
    <td>
     <code>
      TOKEN_LIST
     </code>
    </td>
    <td>
     <code>
      1
     </code>
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     <code>
      TOKEN_LATTICE
     </code>
    </td>
    <td>
     <code>
      2
     </code>
    </td>
    <td>
    </td>
   </tr>
  </table>
 </div>
</div>
<hr/>
<div id="Structs_div">
 <h2 id="Structs">
  Data structures
 </h2>
 <div class="definition">
  <h3 id="Struct_Arc">
   Struct: Arc
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     src
    </td>
    <td>
     <code>
      i32
     </code>
    </td>
    <td>
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     dst
    </td>
    <td>
     <code>
      i32
     </code>
    </td>
    <td>
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     3
    </td>
    <td>
     token
    </td>
    <td>
     <code>
      <a href="#Struct_Token">
       Token
      </a>
     </code>
    </td>
    <td>
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     4
    </td>
    <td>
     weight
    </td>
    <td>
     <code>
      double
     </code>
    </td>
    <td>
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
  Type for arcs. For epsilon edges, leave 'token' blank.
  <br/>
 </div>
 <div class="definition">
  <h3 id="Struct_Constituent">
   Struct: Constituent
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     id
    </td>
    <td>
     <code>
      i32
     </code>
    </td>
    <td>
     A parse-relative identifier for this consistuent. Together
with the UUID for a Parse, this can be used to define
pointers to specific constituents.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     tag
    </td>
    <td>
     <code>
      string
     </code>
    </td>
    <td>
     A description of this constituency node, e.g. the category "NP".
For leaf nodes, this should be a word and for pre-terminal nodes
this should be a POS tag.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     3
    </td>
    <td>
     childList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       i32
      </code>
      &gt;
     </code>
    </td>
    <td>
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     4
    </td>
    <td>
     headChildIndex
    </td>
    <td>
     <code>
      i32
     </code>
    </td>
    <td>
     The index of the head child of this constituent. I.e., the
head child of constituent
     <tt>
      c
     </tt>
     is
     <tt>
      c.children[c.head_child_index]
     </tt>
     . A value of -1
indicates that no child head was identified.
    </td>
    <td>
     optional
    </td>
    <td>
     <code>
      -1
     </code>
    </td>
   </tr>
   <tr>
    <td>
     5
    </td>
    <td>
     start
    </td>
    <td>
     <code>
      i32
     </code>
    </td>
    <td>
     The first token (inclusive) of this constituent in the
parent Tokenization. Almost certainly should be populated.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     6
    </td>
    <td>
     ending
    </td>
    <td>
     <code>
      i32
     </code>
    </td>
    <td>
     The last token (exclusive) of this constituent in the
parent Tokenization. Almost certainly should be populated.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
  A single parse constituent (or "phrase").
  <br/>
 </div>
 <div class="definition">
  <h3 id="Struct_ConstituentRef">
   Struct: ConstituentRef
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     parseId
    </td>
    <td>
     <code>
      <a href="uuid.html#Struct_UUID">
       uuid.UUID
      </a>
     </code>
    </td>
    <td>
     The UUID of the Parse that this Constituent belongs to.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     constituentIndex
    </td>
    <td>
     <code>
      i32
     </code>
    </td>
    <td>
     The index in the constituent list of this Constituent.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
  A reference to a Constituent within a Parse.
  <br/>
 </div>
 <div class="definition">
  <h3 id="Struct_Dependency">
   Struct: Dependency
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     gov
    </td>
    <td>
     <code>
      i32
     </code>
    </td>
    <td>
     The governor or the head token. 0 indexed.
    </td>
    <td>
     optional
    </td>
    <td>
     <code>
      -1
     </code>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     dep
    </td>
    <td>
     <code>
      i32
     </code>
    </td>
    <td>
     The dependent token. 0 indexed.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     3
    </td>
    <td>
     edgeType
    </td>
    <td>
     <code>
      string
     </code>
    </td>
    <td>
     The relation that holds between gov and dep.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
  A syntactic edge between two tokens in a tokenized sentence.
  <br/>
 </div>
 <div class="definition">
  <h3 id="Struct_DependencyParse">
   Struct: DependencyParse
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     uuid
    </td>
    <td>
     <code>
      <a href="uuid.html#Struct_UUID">
       uuid.UUID
      </a>
     </code>
    </td>
    <td>
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     metadata
    </td>
    <td>
     <code>
      <a href="metadata.html#Struct_AnnotationMetadata">
       metadata.AnnotationMetadata
      </a>
     </code>
    </td>
    <td>
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     3
    </td>
    <td>
     dependencyList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       <a href="#Struct_Dependency">
        Dependency
       </a>
      </code>
      &gt;
     </code>
    </td>
    <td>
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     4
    </td>
    <td>
     structureInformation
    </td>
    <td>
     <code>
      <a href="#Struct_DependencyParseStructure">
       DependencyParseStructure
      </a>
     </code>
    </td>
    <td>
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
  Represents a dependency parse with typed edges.
  <br/>
 </div>
 <div class="definition">
  <h3 id="Struct_DependencyParseStructure">
   Struct: DependencyParseStructure
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     isAcyclic
    </td>
    <td>
     <code>
      bool
     </code>
    </td>
    <td>
     True iff there are no cycles in the dependency graph.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     isConnected
    </td>
    <td>
     <code>
      bool
     </code>
    </td>
    <td>
     True iff the dependency graph forms a single connected component.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     3
    </td>
    <td>
     isSingleHeaded
    </td>
    <td>
     <code>
      bool
     </code>
    </td>
    <td>
     True iff every node in the dependency parse has at most
one head/parent/governor.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     4
    </td>
    <td>
     isProjective
    </td>
    <td>
     <code>
      bool
     </code>
    </td>
    <td>
     True iff there are no crossing edges in the dependency parse.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
  Information about the structure of a dependency parse.
This information is computable from the list of dependencies,
but this allows the consumer to make (verified) assumptions
about the dependencies being processed.
  <br/>
 </div>
 <div class="definition">
  <h3 id="Struct_LatticePath">
   Struct: LatticePath
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     weight
    </td>
    <td>
     <code>
      double
     </code>
    </td>
    <td>
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     tokenList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       <a href="#Struct_Token">
        Token
       </a>
      </code>
      &gt;
     </code>
    </td>
    <td>
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
 </div>
 <div class="definition">
  <h3 id="Struct_Parse">
   Struct: Parse
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     uuid
    </td>
    <td>
     <code>
      <a href="uuid.html#Struct_UUID">
       uuid.UUID
      </a>
     </code>
    </td>
    <td>
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     metadata
    </td>
    <td>
     <code>
      <a href="metadata.html#Struct_AnnotationMetadata">
       metadata.AnnotationMetadata
      </a>
     </code>
    </td>
    <td>
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     3
    </td>
    <td>
     constituentList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       <a href="#Struct_Constituent">
        Constituent
       </a>
      </code>
      &gt;
     </code>
    </td>
    <td>
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
  A theory about the syntactic parse of a sentence.

\note If we add support for parse forests in the future, then it
will most likely be done by adding a new field (e.g.
"
  <tt>
   forest_root
  </tt>
  ") that uses a new struct type to encode the
forest. A "
  <tt>
   kind
  </tt>
  " field might also be added (analogous to
  <tt>
   Tokenization.kind
  </tt>
  ) to indicate whether a parse is encoded
using a simple tree or a parse forest.
  <br/>
 </div>
 <div class="definition">
  <h3 id="Struct_Section">
   Struct: Section
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     uuid
    </td>
    <td>
     <code>
      <a href="uuid.html#Struct_UUID">
       uuid.UUID
      </a>
     </code>
    </td>
    <td>
     The unique identifier for this section.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     sentenceList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       <a href="#Struct_Sentence">
        Sentence
       </a>
      </code>
      &gt;
     </code>
    </td>
    <td>
     The sentences of this "section."
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     3
    </td>
    <td>
     textSpan
    </td>
    <td>
     <code>
      <a href="spans.html#Struct_TextSpan">
       spans.TextSpan
      </a>
     </code>
    </td>
    <td>
     Location of this section in the communication text.

NOTE: This text span represents a best guess, or 'provenance':
it cannot be guaranteed that this text span matches the _exact_
text of the original document, but is the annotation's best
effort at such a representation.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     4
    </td>
    <td>
     rawTextSpan
    </td>
    <td>
     <code>
      <a href="spans.html#Struct_TextSpan">
       spans.TextSpan
      </a>
     </code>
    </td>
    <td>
     Location of this section in the raw text.

NOTE: This text span represents a best guess, or 'provenance':
it cannot be guaranteed that this text span matches the _exact_
text of the original document, but is the annotation's best
effort at such a representation.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     9
    </td>
    <td>
     audioSpan
    </td>
    <td>
     <code>
      <a href="spans.html#Struct_AudioSpan">
       spans.AudioSpan
      </a>
     </code>
    </td>
    <td>
     Location of this section in the original audio.

NOTE: This span represents a best guess, or 'provenance':
it cannot be guaranteed that this text span matches the _exact_
text of the original document, but is the annotation's best
effort at such a representation.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     5
    </td>
    <td>
     kind
    </td>
    <td>
     <code>
      string
     </code>
    </td>
    <td>
     A short, sometimes corpus-specific term characterizing the nature
of the section; may change in a future version of concrete.  This
often acts as a coarse-grained descriptor that is used for
filtering.  For example, Gigaword uses the section kind "passage"
to distinguish content-bearing paragraphs in the body of an
article from other paragraphs, such as the headline and dateline.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     6
    </td>
    <td>
     label
    </td>
    <td>
     <code>
      string
     </code>
    </td>
    <td>
     The name of the section. For example, a title of a section on
Wikipedia.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     7
    </td>
    <td>
     numberList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       i32
      </code>
      &gt;
     </code>
    </td>
    <td>
     Position within the communication with respect to other Sections:
The section number, E.g., 3, or 3.1, or 3.1.2, etc. Aimed at
Communications with content organized in a hierarchy, such as a Book
with multiple chapters, then sections, then paragraphs. Or even a
dense Wikipedia page with subsections. Sections should still be
arranged linearly, where reading these numbers should not be required
to get a start-to-finish enumeration of the Communication's content.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     8
    </td>
    <td>
     lidList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       <a href="language.html#Struct_LanguageIdentification">
        language.LanguageIdentification
       </a>
      </code>
      &gt;
     </code>
    </td>
    <td>
     An optional field to be used for multi-language documents.

This field should be populated when a section is inside of
a document that contains multiple languages.

Minimally, each block of text in one language should be it's own
section. For example, if a paragraph is in English and the
paragraph afterwards is in French, these should be separated into
two different sections, allowing language-specific analytics to
run on appropriate sections.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
  A single "section" of a communication, such as a paragraph. Each
section is defined using a text or audio span, and can optionally
contain a list of sentences.
  <br/>
 </div> <div class="definition">
  <h3 id="Struct_Sentence">
   Struct: Sentence
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     uuid
    </td>
    <td>
     <code>
      <a href="uuid.html#Struct_UUID">
       uuid.UUID
      </a>
     </code>
    </td>
    <td>
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     tokenization
    </td>
    <td>
     <code>
      <a href="#Struct_Tokenization">
       Tokenization
      </a>
     </code>
    </td>
    <td>
     Theory about the tokens that make up this sentence.  For text
communications, these tokenizations will typically be generated
by a tokenizer.  For audio communications, these tokenizations
will typically be generated by an automatic speech recognizer.

The "Tokenization" message type is also used to store the output
of machine translation systems and text normalization
systems.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     3
    </td>
    <td>
     textSpan
    </td>
    <td>
     <code>
      <a href="spans.html#Struct_TextSpan">
       spans.TextSpan
      </a>
     </code>
    </td>
    <td>
     Location of this sentence in the communication text.

NOTE: This span represents a best guess, or 'provenance':
it cannot be guaranteed that this text span matches the _exact_
text of the original document, but is the annotation's best
effort at such a representation.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     4
    </td>
    <td>
     rawTextSpan
    </td>
    <td>
     <code>
      <a href="spans.html#Struct_TextSpan">
       spans.TextSpan
      </a>
     </code>
    </td>
    <td>
     Location of this sentence in the raw text.

NOTE: This span represents a best guess, or 'provenance':
it cannot be guaranteed that this text span matches the _exact_
text of the original document, but is the annotation's best
effort at such a representation.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     5
    </td>
    <td>
     audioSpan
    </td>
    <td>
     <code>
      <a href="spans.html#Struct_AudioSpan">
       spans.AudioSpan
      </a>
     </code>
    </td>
    <td>
     Location of this sentence in the original audio.

NOTE: This span represents a best guess, or 'provenance':
it cannot be guaranteed that this text span matches the _exact_
text of the original document, but is the annotation's best
effort at such a representation.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
  A single sentence or utterance in a communication.
  <br/>
 </div>
 <div class="definition">
  <h3 id="Struct_SpanLink">
   Struct: SpanLink
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     tokens
    </td>
    <td>
     <code>
      <a href="#Struct_TokenRefSequence">
       TokenRefSequence
      </a>
     </code>
    </td>
    <td>
     The tokens that make up this SpanLink object.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     concreteTarget
    </td>
    <td>
     <code>
      <a href="uuid.html#Struct_UUID">
       uuid.UUID
      </a>
     </code>
    </td>
    <td>
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     3
    </td>
    <td>
     externalTarget
    </td>
    <td>
     <code>
      string
     </code>
    </td>
    <td>
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     4
    </td>
    <td>
     linkType
    </td>
    <td>
     <code>
      string
     </code>
    </td>
    <td>
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
  A collection of tokens that represent a link to another resource.
This resource might be another Concrete object (e.g., another
Concrete Communication), represented with the 'concreteTarget'
field, or it could link to a resource outside of Concrete via the
'externalTarget' field.
  <br/>
 </div>
 <div class="definition">
  <h3 id="Struct_TaggedToken">
   Struct: TaggedToken
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     tokenIndex
    </td>
    <td>
     <code>
      i32
     </code>
    </td>
    <td>
     A pointer to the token being tagged.

Token indices are 0-based. These indices are also 0-based.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     tag
    </td>
    <td>
     <code>
      string
     </code>
    </td>
    <td>
     A string containing the annotation.
If the tag set you are using is not case sensitive,
then all part of speech tags should be normalized to upper case.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     3
    </td>
    <td>
     confidence
    </td>
    <td>
     <code>
      double
     </code>
    </td>
    <td>
     Confidence of the annotation.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     4
    </td>
    <td>
     tagList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       string
      </code>
      &gt;
     </code>
    </td>
    <td>
     A list of strings that represent a distribution of possible
tags for this token.

If populated, the 'tag' field should also be populated
with the "best" value from this list.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     5
    </td>
    <td>
     confidenceList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       double
      </code>
      &gt;
     </code>
    </td>
    <td>
     A list of doubles that represent confidences associated with
the tags in the 'tagList' field.

If populated, the 'confidence' field should also be populated
with the confidence associated with the "best" tag in 'tagList'.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
 </div>
 <div class="definition">
  <h3 id="Struct_Token">
   Struct: Token
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     tokenIndex
    </td>
    <td>
     <code>
      i32
     </code>
    </td>
    <td>
     A 0-based tokenization-relative identifier for this token that
represents the order that this token appears in the
sentence. Together with the UUID for a Tokenization, this can be
used to define pointers to specific tokens. If a Tokenization
object contains multiple Token objects with the same id (e.g., in
different n-best lists), then all of their other fields *must* be
identical as well.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     text
    </td>
    <td>
     <code>
      string
     </code>
    </td>
    <td>
     The text associated with this token.
Note - we may have a destructive tokenizer (e.g., Stanford rewriting)
and as a result, we want to maintain this field.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     3
    </td>
    <td>
     textSpan
    </td>
    <td>
     <code>
      <a href="spans.html#Struct_TextSpan">
       spans.TextSpan
      </a>
     </code>
    </td>
    <td>
     Location of this token in this perspective's text (.text field).
In cases where this token does not correspond directly with any
text span in the text (such as word insertion during MT),
this field may be given a value indicating "approximately" where
the token comes from. A span covering the entire sentence may be
used if no more precise value seems appropriate.

NOTE: This span represents a best guess, or 'provenance':
it cannot be guaranteed that this text span matches the _exact_
text of the document, but is the annotation's best
effort at such a representation.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     4
    </td>
    <td>
     rawTextSpan
    </td>
    <td>
     <code>
      <a href="spans.html#Struct_TextSpan">
       spans.TextSpan
      </a>
     </code>
    </td>
    <td>
     Location of this token in the original, raw text (.originalText
field).  In cases where this token does not correspond directly
with any text span in the original text (such as word insertion
during MT), this field may be given a value indicating
"approximately" where the token comes from. A span covering the
entire sentence may be used if no more precise value seems
appropriate.

NOTE: This span represents a best guess, or 'provenance':
it cannot be guaranteed that this text span matches the _exact_
text of the original raw document, but is the annotation's best
effort at such a representation.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     5
    </td>
    <td>
     audioSpan
    </td>
    <td>
     <code>
      <a href="spans.html#Struct_AudioSpan">
       spans.AudioSpan
      </a>
     </code>
    </td>
    <td>
     Location of this token in the original audio.

NOTE: This span represents a best guess, or 'provenance':
it cannot be guaranteed that this text span matches the _exact_
text of the original document, but is the annotation's best
effort at such a representation.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
  A single token (typically a word) in a communication. The exact
definition of what counts as a token is left up to the tools that
generate token sequences.

Usually, each token will include at least a text string.
  <br/>
 </div>
 <div class="definition">
  <h3 id="Struct_TokenLattice">
   Struct: TokenLattice
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     startState
    </td>
    <td>
     <code>
      i32
     </code>
    </td>
    <td>
    </td>
    <td>
     optional
    </td>
    <td>
     <code>
      0
     </code>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     endState
    </td>
    <td>
     <code>
      i32
     </code>
    </td>
    <td>
    </td>
    <td>
     optional
    </td>
    <td>
     <code>
      0
     </code>
    </td>
   </tr>
   <tr>
    <td>
     3
    </td>
    <td>
     arcList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       <a href="#Struct_Arc">
        Arc
       </a>
      </code>
      &gt;
     </code>
    </td>
    <td>
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     4
    </td>
    <td>
     cachedBestPath
    </td>
    <td>
     <code>
      <a href="#Struct_LatticePath">
       LatticePath
      </a>
     </code>
    </td>
    <td>
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
  A lattice structure that assigns scores to a set of token
sequences.  The lattice is encoded as an FSA, where states are
identified by integers, and each arc is annotated with an
optional tokens and a weight.  (Arcs with no tokens are
"epsilon" arcs.)  The lattice has a single start state and a
single end state.  (You can use epsilon edges to simulate
multiple start states or multiple end states, if desired.)

The score of a path through the lattice is the sum of the weights
of the arcs that make up that path.  A path with a lower score
is considered "better" than a path with a higher score.

If possible, path scores should be negative log likelihoods
(with base e -- e.g. if P=1, then weight=0; and if P=0.5, then
weight=0.693).  Furthermore, if possible, the path scores should
be globally normalized (i.e., they should encode probabilities).
This will allow for them to be combined with other information
in a reasonable way when determining confidences for system
outputs.

TokenLattices should never contain any paths with cycles.  Every
arc in the lattice should be included in some path from the start
state to the end state.
  <br/>
 </div>
 <div class="definition">
  <h3 id="Struct_TokenList">
   Struct: TokenList
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     tokenList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       <a href="#Struct_Token">
        Token
       </a>
      </code>
      &gt;
     </code>
    </td>
    <td>
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
  A wrapper around a list of tokens.
  <br/>
 </div>
 <div class="definition">
  <h3 id="Struct_TokenRefSequence">
   Struct: TokenRefSequence
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     tokenIndexList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       i32
      </code>
      &gt;
     </code>
    </td>
    <td>
     The tokenization-relative identifiers for each token that is
included in this sequence.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     anchorTokenIndex
    </td>
    <td>
     <code>
      i32
     </code>
    </td>
    <td>
     An optional field that can be used to describe
the root of a sentence (if this sequence is a full sentence),
the head of a constituent (if this sequence is a constituent),
or some other form of "canonical" token in this sequence if,
for instance, it is not easy to map this sequence to a another
annotation that has a head.

This field is defined with respect to the Tokenization given
by tokenizationId, and not to this object's tokenIndexList.
    </td>
    <td>
     optional
    </td>
    <td>
     <code>
      -1
     </code>
    </td>
   </tr>
   <tr>
    <td>
     3
    </td>
    <td>
     tokenizationId
    </td>
    <td>
     <code>
      <a href="uuid.html#Struct_UUID">
       uuid.UUID
      </a>
     </code>
    </td>
    <td>
     The UUID of the tokenization that contains the tokens.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     4
    </td>
    <td>
     textSpan
    </td>
    <td>
     <code>
      <a href="spans.html#Struct_TextSpan">
       spans.TextSpan
      </a>
     </code>
    </td>
    <td>
     The text span in the main text (.text field) associated with this
TokenRefSequence.

NOTE: This span represents a best guess, or 'provenance': it
cannot be guaranteed that this text span matches the _exact_ text
of the original document, but is the annotation's best effort at
such a representation.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     5
    </td>
    <td>
     rawTextSpan
    </td>
    <td>
     <code>
      <a href="spans.html#Struct_TextSpan">
       spans.TextSpan
      </a>
     </code>
    </td>
    <td>
     The text span in the original text (.originalText field)
associated with this TokenRefSequence.

NOTE: This span represents a best guess, or 'provenance': it
cannot be guaranteed that this text span matches the _exact_ text
of the original raw document, but is the annotation's best effort
at such a representation.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     6
    </td>
    <td>
     audioSpan
    </td>
    <td>
     <code>
      <a href="spans.html#Struct_AudioSpan">
       spans.AudioSpan
      </a>
     </code>
    </td>
    <td>
     The audio span associated with this TokenRefSequence.

NOTE: This span represents a best guess, or 'provenance':
it cannot be guaranteed that this text span matches the _exact_
text of the original document, but is the annotation's best
effort at such a representation.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     7
    </td>
    <td>
     dependencies
    </td>
    <td>
     <code>
      list&lt;
      <code>
       <a href="#Struct_Dependency">
        Dependency
       </a>
      </code>
      &gt;
     </code>
    </td>
    <td>
     Use this field to reference a dependency tree fragment
such as a shortest path or all the dependents in a constituent.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     8
    </td>
    <td>
     constituent
    </td>
    <td>
     <code>
      <a href="#Struct_ConstituentRef">
       ConstituentRef
      </a>
     </code>
    </td>
    <td>
     Use this field to specify an entire constituent in a parse tree.
Prefer textSpan over this field unless a node in a tree is needed.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
  A list of pointers to tokens that all belong to the same
tokenization.
  <br/>
 </div>
 <div class="definition">
  <h3 id="Struct_TokenTagging">
   Struct: TokenTagging
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     uuid
    </td>
    <td>
     <code>
      <a href="uuid.html#Struct_UUID">
       uuid.UUID
      </a>
     </code>
    </td>
    <td>
     The UUID of this TokenTagging object.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     metadata
    </td>
    <td>
     <code>
      <a href="metadata.html#Struct_AnnotationMetadata">
       metadata.AnnotationMetadata
      </a>
     </code>
    </td>
    <td>
     Information about where the annotation came from.
This should be used to tell between gold-standard annotations
and automatically generated theories about the data
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     3
    </td>
    <td>
     taggedTokenList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       <a href="#Struct_TaggedToken">
        TaggedToken
       </a>
      </code>
      &gt;
     </code>
    </td>
    <td>
     The mapping from tokens to annotations.
This may be a partial mapping.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     4
    </td>
    <td>
     taggingType
    </td>
    <td>
     <code>
      string
     </code>
    </td>
    <td>
     An ontology-backed string that represents the
type of token taggings this TokenTagging object
produces.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
  A theory about some token-level annotation.
The TokenTagging consists of a mapping from tokens
(using token ids) to string tags (e.g. part-of-speech tags or lemmas).

The mapping defined by a TokenTagging may be partial --
i.e., some tokens may not be assigned any part of speech tags.

For lattice tokenizations, you may need to create multiple
part-of-speech taggings (for different paths through the lattice),
since the appropriate tag for a given token may depend on the path
taken. For example, you might define a separate
TokenTagging for each of the top K paths, which leaves all
tokens that are not part of the path unlabeled.

Currently, we use strings to encode annotations. In
the future, we may add fields for encoding specific tag sets
(eg treebank tags), or for adding compound tags.
  <br/>
 </div>
 <div class="definition">
  <h3 id="Struct_Tokenization">
   Struct: Tokenization
  </h3>
  <table class="table-bordered table-striped table-condensed">
   <thead>
    <th>
     Key
    </th>
    <th>
     Field
    </th>
    <th>
     Type
    </th>
    <th>
     Description
    </th>
    <th>
     Requiredness
    </th>
    <th>
     Default value
    </th>
   </thead>
   <tr>
    <td>
     1
    </td>
    <td>
     uuid
    </td>
    <td>
     <code>
      <a href="uuid.html#Struct_UUID">
       uuid.UUID
      </a>
     </code>
    </td>
    <td>
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     2
    </td>
    <td>
     metadata
    </td>
    <td>
     <code>
      <a href="metadata.html#Struct_AnnotationMetadata">
       metadata.AnnotationMetadata
      </a>
     </code>
    </td>
    <td>
     Information about where this tokenization came from.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     3
    </td>
    <td>
     tokenList
    </td>
    <td>
     <code>
      <a href="#Struct_TokenList">
       TokenList
      </a>
     </code>
    </td>
    <td>
     A wrapper around an ordered list of the tokens in this tokenization.
This may also give easy access to the "reconstructed text" associated
with this tokenization.
This field should only have a value if kind==TOKEN_LIST.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     4
    </td>
    <td>
     lattice
    </td>
    <td>
     <code>
      <a href="#Struct_TokenLattice">
       TokenLattice
      </a>
     </code>
    </td>
    <td>
     A lattice that compactly describes a set of token sequences that
might make up this tokenization.  This field should only have a
value if kind==LATTICE.
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     5
    </td>
    <td>
     kind
    </td>
    <td>
     <code>
      <a href="#Enum_TokenizationKind">
       TokenizationKind
      </a>
     </code>
    </td>
    <td>
     Enumerated value indicating whether this tokenization is
implemented using an n-best list or a lattice.
    </td>
    <td>
     required
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     6
    </td>
    <td>
     tokenTaggingList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       <a href="#Struct_TokenTagging">
        TokenTagging
       </a>
      </code>
      &gt;
     </code>
    </td>
    <td>
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     7
    </td>
    <td>
     parseList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       <a href="#Struct_Parse">
        Parse
       </a>
      </code>
      &gt;
     </code>
    </td>
    <td>
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     8
    </td>
    <td>
     dependencyParseList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       <a href="#Struct_DependencyParse">
        DependencyParse
       </a>
      </code>
      &gt;
     </code>
    </td>
    <td>
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
   <tr>
    <td>
     9
    </td>
    <td>
     spanLinkList
    </td>
    <td>
     <code>
      list&lt;
      <code>
       <a href="#Struct_SpanLink">
        SpanLink
       </a>
      </code>
      &gt;
     </code>
    </td>
    <td>
    </td>
    <td>
     optional
    </td>
    <td>
    </td>
   </tr>
  </table>
  <br/>
  A theory (or set of alternative theories) about the sequence of
tokens that make up a sentence.

This message type is used to record the output of not just for
tokenizers, but also for a wide variety of other tools, including
machine translation systems, text normalizers, part-of-speech
taggers, and stemmers.

Each Tokenization is encoded using either a TokenList
or a TokenLattice. (If you want to encode an n-best list, then
you should store it as n separate Tokenization objects.) The
"kind" field is used to indicate whether this Tokenization contains
a list of tokens or a TokenLattice.

The confidence value for each sequence is determined by combining
the confidence from the "metadata" field with confidence
information from individual token sequences as follows:
  <ul>
   <li>
    For n-best lists:
metadata.confidence
   </li>
   <li>
    For lattices:
metadata.confidence * exp(-sum(arc.weight))
   </li>
  </ul>
  Note: in some cases (such as the output of a machine translation
tool), the order of the tokens in a token sequence may not
correspond with the order of their original text span offsets.
  <br/>
 </div>
</div>

